---
title: linear-list
description: 线性表
tags: [数据结构,线性表]
time: '2020-06-08'
id: linear-list
---
## 类型定义
关键字：序列，有限，有序/无序，前驱元素，后继元素\
线性结构：唯一一个‘第一个元素’、唯一一个‘最后一个元素’、除头外，都有一个前驱元素、除尾外，都有一个后继元素
# 线性表
n个==数据元素==的有限序列
## 顺序表示-顺序表
定义：顺序存储的线性结构，便于随机存取
关键字：逻辑顺序，连续存储空间
````C
数组长度和线性表的长度区别：数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的，线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。
````
````javascript
// 插入/删除的移动操作

````
## 链式表示-链表
关键字：连续/非连续存储，节点，指针域，数据域
### 线性链表（静态链表）
特点：用一组任意的存储单元存储线性表的数据元素\
用数组来模仿线性链表，两个数据域来分别表示数据元素和next指针
### 循环链表
特点：表的最后一个节点指向头节点，整个链形成一个环，由任意元素出发，均可找到所需元素
### 双向链表
特点：节点拥有两个指针域

## 练习
````javascript
1.数据项 -> 数据元素 -> 序列(线性表)
2.判断一个单向链表中是否存在环的最佳方法：快慢指针
3.栈具有记忆功能：参考浏览器的前进后退
4.操作是否与链表长度有关：链表长度是否会影响到被操作元素的查找
5.二叉链表：左孩子右兄弟
6.顺序表：在结点等长时可以随机存取（即在各个节点大小一致的情况下，可以取任意元素）
7.随机数，未经排序，二叉树不适合；需要遍历，hash表不适合；不强调数据之间的关系，图不适合；
8.非空广义表，第一个元素是表头，后面的元素多是表尾（一定是子表）

广义表K=(m,n,(p,(q,s)),(h,f)),则head[tail[head[tail[tail(K)]]]]的值为

head() 返回列表的第一个元素；
tail() 返回列表的删去第一个元素之后的剩余列表；
K=(m,n,(p,(q,s)),(h,f)),
head[tail[head[tail[tail(K)]]]]
tail(K)-------(n,(p,(q,s)),(h,f))
tail[tail[K]]--------((p,(q,s)),(h,f))
head()-----((p,(q,s))
tail()-----(q,s)
head()-------q

循环队列
````
* 快慢指针：让快慢指针都从链表表头开始，快指针一次向前移动两个位置，慢指针每次向前移动一个位置。如果快指针到达了NULL，说明不存在环，但如果快指针追上了慢指针，说明存在环。
* 链域：指针域，将节点链接在一起，n个节点需要n-1个非空链域（根结点不需要）相连，N个结点的二叉链表中必定有2N个链域。


````javascript
附录-频繁插入和删除使用 list
1.vector  底层数据结构为数组 ，支持快速随机访问

2.list    底层数据结构为双向链表，支持快速增删

3.deque   底层数据结构为一个***控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问

4.stack   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时

5.queue   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时

6.45是适配器,而不叫容器，因为是对容器的再封装

7.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现

8.set       底层数据结构为红黑树，有序，不重复

9.multiset  底层数据结构为红黑树，有序，可重复 

10.map      ﻿﻿﻿﻿底层数据结构为红黑树，有序，不重复

11.multimap 底层数据结构为红黑树，有序，可重复

12.hash_set ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复

13.hash_multiset 底层数据结构为hash表，无序，可重复 

14.hash_map      ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复

15.hash_multimap 底层数据结构为hash表，无序，可重复 

````